// SPDX-License-Identifier: GPL-3.0
// solhint-disable-next-line
pragma solidity >=0.8.7;
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "./interfaces/IVestingNFT.sol";
import "./interfaces/IGenesisBond.sol";

/**
 * @dev {ERC721} token, including:
 *
 *  - a minter role that allows for token minting (creation)
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 */
contract GenesisBondNft is IVestingNFT, AccessControlEnumerableUpgradeable, ERC721EnumerableUpgradeable, UUPSUpgradeable, OwnableUpgradeable {
    using CountersUpgradeable for CountersUpgradeable.Counter;
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant URI_SETTER_ROLE = keccak256("URI_SETTER_ROLE");
    bytes32 public constant FACTORY_ROLE = keccak256("FACTORY_ROLE");

    CountersUpgradeable.Counter private _tokenIdTracker;
    mapping(uint256 => address) public bondAddresses; // stores bond address for nfts

    struct TokenData {
        uint256 tokenId;
        address bondAddress;
    }

    string private _baseTokenURI;

    bool public uriLocked;

    using StringsUpgradeable for uint256;

    // Optional mapping for token URIs
    mapping(uint256 => string) private _tokenURIs;

    event BaseTokenUriChanged(string newUri);
    event UriLocked(bool locked);

    modifier onlyAdmin() {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BondNft: Only admin role");
        _;
    }

    modifier onlyMinter() {
        require(hasRole(MINTER_ROLE, _msgSender()), "BondNft: Only minter role");
        _;
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE` to the owner account.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    function initialize(
      string memory name,
      string memory symbol,
      string memory baseTokenURI,
      address factory,
      address owner,
      address proxyOwner
    ) public initializer {
        __ERC721_init(name, symbol);
        __ERC721Enumerable_init();
        __AccessControlEnumerable_init();
        __Ownable_init();

        transferOwnership(proxyOwner);

        _baseTokenURI = baseTokenURI;

        // Allows proxy owner set GenesisBond contract as minter
        // This role is revoked during the proxy deployment after GenesisBond role is set
        _setupRole(FACTORY_ROLE, factory);

        _setupRole(DEFAULT_ADMIN_ROLE, owner);
        _setupRole(URI_SETTER_ROLE, owner);


        // Start BondNfts tokenIds at 1
        _tokenIdTracker.increment();

        uriLocked = false;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    function setBaseURI(string memory baseTokenURI) external onlyAdmin {
        require(!uriLocked, "Not happening.");
        _baseTokenURI = baseTokenURI;
        emit BaseTokenUriChanged(_baseTokenURI);
    }

    function lockURI() external onlyAdmin {
        uriLocked = true;
        emit UriLocked(uriLocked);
    }

    function addMinter(address minter) external {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()) || hasRole(FACTORY_ROLE, _msgSender()), "Only admin or factory role");

        _setupRole(MINTER_ROLE, minter);
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to, address bondAddress) external onlyMinter returns (uint256 newTokenId) {
        return _mintInternal(to, bondAddress);
    }

    function mintMany(uint256 amount, address to, address bondAddress) external onlyMinter {
        for(uint i = 0; i < amount; i++){
            _mintInternal(to, bondAddress);
        }
    }

    function _mintInternal(address to, address bondAddress) internal  returns (uint256 newTokenId) {
        newTokenId = _tokenIdTracker.current();
        _mint(to, newTokenId);
        bondAddresses[newTokenId] = bondAddress;
        _tokenIdTracker.increment();
    }


    function allTokensDataOfOwner(address owner) external view returns (TokenData[] memory) {
        uint256 length = ERC721Upgradeable.balanceOf(owner);
        return getTokensOfOwnerByIndexes(owner, 0, length);
    }

    function getTokensOfOwnerByIndexes(address owner, uint256 start, uint256 end) public view returns (TokenData[] memory) {
        TokenData[] memory result = new TokenData[](end - start);
        for (uint i = start; i < end; i++) {
            TokenData memory tokenData = tokenDataOfOwnerByIndex(owner, i);
            result[i - start] = tokenData;
        }
        return result;
    }

    function tokenDataOfOwnerByIndex(address owner, uint256 index) public view returns (TokenData memory tokenData) {
        uint256 tokenId = tokenOfOwnerByIndex(owner, index);
        address bondAddress = bondAddresses[tokenId];
        tokenData = TokenData({
            tokenId: tokenId,
            bondAddress: bondAddress
        });
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view override(AccessControlEnumerableUpgradeable, ERC721EnumerableUpgradeable) returns (bool) {
        return AccessControlEnumerableUpgradeable.supportsInterface(interfaceId) || ERC721EnumerableUpgradeable.supportsInterface(interfaceId);    
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721URIStorage: URI query for nonexistent token");

        string memory _tokenURI = _tokenURIs[tokenId];

        if (bytes(_tokenURI).length > 0) {
            return _tokenURI;
        }

        return super.tokenURI(tokenId);
    }

    function setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
        require(hasRole(URI_SETTER_ROLE, _msgSender()), "BondNft: Only uri setter role");
        _setTokenURI(tokenId, _tokenURI);
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
        require(_exists(tokenId), "URI set of nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }

    function claim(uint256 tokenId) public {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "Not approved");
        IGenesisBond bond = IGenesisBond(bondAddresses[tokenId]);
        bond.redeem(tokenId);
    }

    function claimMany(uint256[] calldata _tokenIds) external {
        uint256 length = _tokenIds.length;
         for (uint i = 0; i < length; i++) { 
            claim(_tokenIds[i]);
        }
    }

    /**
     * @dev Returns the vested payout of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function vestedPayout(uint256 tokenId) external view returns (uint256 payout) {
        IGenesisBond bond = IGenesisBond(bondAddresses[tokenId]);
        payout = bond.pendingPayoutFor(tokenId);
    }

    /**
     * @dev Returns the payout of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function pendingPayout(uint256 tokenId) external view returns (uint256 payout) {
        payout = IGenesisBond(bondAddresses[tokenId]).bondInfo(tokenId).payout;
    }

    /**
     * @dev Returns the remaining vesting in seconds of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function pendingVesting(uint256 tokenId) external view returns (uint256 vestingSeconds) {
        IGenesisBond bond = IGenesisBond(bondAddresses[tokenId]);
        vestingSeconds = bond.pendingVesting(tokenId);
    }

    /**
     * @dev Returns the payout token of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function payoutToken(uint256 tokenId) external view returns (address tokenAddress) {
        tokenAddress = IGenesisBond(bondAddresses[tokenId]).payoutToken();
    }

    function _authorizeUpgrade(address) internal override onlyOwner {}
}